#include <iostream>

class Node {
public:
    int data;
    Node* prev;
    Node* next;
    
    Node(int value) : data(value), prev(nullptr), next(nullptr) {}
};

class DoublyLinkedList {
private:
    Node* head;
    Node* tail;

public:
    DoublyLinkedList() : head(nullptr), tail(nullptr) {}

    void addToFront(int value) {
        Node* newNode = new Node(value);
        if (!head) {
            head = tail = newNode;
        } else {
            newNode->next = head;
            head->prev = newNode;
            head = newNode;
        }
    }

    void removeFromEnd() {
        if (!tail) {
            std::cout << "The list is empty." << std::endl;
        } else if (head == tail) {
            delete tail;
            head = tail = nullptr;
        } else {
            Node* temp = tail;
            tail = tail->prev;
            tail->next = nullptr;
            delete temp;
        }
    }

    int findAtIndex(int index) {
        Node* current = head;
        int currentIndex = 0;
        while (current != nullptr && currentIndex < index) {
            current = current->next;
            currentIndex++;
        }
        if (current == nullptr) {
            std::cout << "Index out of bounds." << std::endl;
            return -1;
        }
        return current->data;
    }

    bool contains(int element) {
        Node* current = head;
        while (current != nullptr) {
            if (current->data == element) {
                return true;
            }
            current = current->next;
        }
        return false;
    }

    void reverse() {
        Node* temp = nullptr;
        Node* current = head;
        while (current != nullptr) {
            temp = current->prev;
            current->prev = current->next;
            current->next = temp;
            current = current->prev;
        }
        if (temp != nullptr) {
            head = temp->prev;
        }
    }

    void insertAtIndex(int index, int element) {
        if (index == 0) {
            addToFront(element);
            return;
        }
        Node* newNode = new Node(element);
        Node* current = head;
        int currentIndex = 0;
        while (current != nullptr && currentIndex < index - 1) {
            current = current->next;
            currentIndex++;
        }
        if (current == nullptr) {
            std::cout << "Index out of bounds." << std::endl;
            return;
        }
        newNode->next = current->next;
        newNode->prev = current;
        if (current->next) {
            current->next->prev = newNode;
        }
        current->next = newNode;
    }

    void deleteElement(int element) {
        Node* current = head;
        while (current != nullptr) {
            if (current->data == element) {
                if (current == head) {
                    removeFromFront();
                } else if (current == tail) {
                    removeFromEnd();
                } else {
                    current->prev->next = current->next;
                    current->next->prev = current->prev;
                    delete current;
                }
                return;
            }
            current = current->next;
        }
    }

    bool isPalindrome() {
        Node* front = head;
        Node* back = tail;
        while (front != nullptr && back != nullptr) {
            if (front->data != back->data) {
                return false;
            }
            front = front->next;
            back = back->prev;
        }
        return true;
    }

    void printList() {
        Node* current = head;
        std::cout << "Doubly linked list containing the elements: [";
        while (current != nullptr) {
            std::cout << current->data;
            if (current->next != nullptr) {
                std::cout << ", ";
            }
            current = current->next;
        }
        std::cout << "]" << std::endl;
    }
};

int main() {
    DoublyLinkedList list;

    list.addToFront(5);
    list.addToFront(4);
    list.addToFront(3);
    list.addToFront(2);
    list.addToFront(1);

    list.printList();

    list.addToFront(0);
    list.printList();

    list.removeFromEnd();
    list.printList();

    int index = 2;
    int elementAtIndex = list.findAtIndex(index);
    if (elementAtIndex != -1) {
        std::cout << "Element at index " << index << ": " << elementAtIndex << std::endl;
    }

    int elementToFind = 3;
    bool containsElement = list.contains(elementToFind);
    std::cout << "Contains " << elementToFind << ": " << (containsElement ? "True" : "False") << std::endl;

    list.reverse();
    list.printList();

    int insertIndex = 1;
    int insertElement = 0;
    list.insertAtIndex(insertIndex, insertElement);
    list.printList();

    int deleteElement = 6;
    list.deleteElement(deleteElement);
    list.printList();

    DoublyLinkedList palindromeList;
    palindromeList.addToFront(1);
    palindromeList.addToFront(2);
    palindromeList.addToFront(3);
    palindromeList.addToFront(2);
    palindromeList.addToFront(1);

    bool isPalindrome = palindromeList.isPalindrome();
    std::cout << "Is palindrome: " << (isPalindrome ? "True" : "False") << std::endl;

    return 0;
}

